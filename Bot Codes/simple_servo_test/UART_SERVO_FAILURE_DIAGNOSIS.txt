================================================================================
UART/SERIAL SERVO COMMUNICATION - FAILURE DIAGNOSIS GUIDE
================================================================================
For SMS/Feetech servos using Modbus RTU over UART (RS-485/TTL)
Code: simple_servo_test.ino
Date: 2 December 2025

This document provides exhaustive failure modes, root causes, and diagnostics
for UART-based servo communication, similar to CAN's TWAI alerts and SDO aborts.

================================================================================
1. ERROR CATEGORIES & RETURN CODES
================================================================================

Return Code    Meaning                          Similar to CAN
-----------    -------                          --------------
  -1          Timeout / Incomplete Read        CAN_RX_TIMEOUT
  -2          CRC Mismatch                     SDO_ABORT (data corruption)
   0          Function returned false          Command rejected
  >0          Success (bytes read)             CAN_OK

================================================================================
2. PHYSICAL / WIRING LAYER FAILURES
================================================================================

2.1 NO RESPONSE FROM SERVO (bytesRead = 0)
───────────────────────────────────────────────────────────────────────────────
Error Pattern:
  • readResponse() returns -1
  • bytesRead = 0 (no bytes received at all)
  • Console: "NO RESPONSE from servo"

Root Causes:
  ✗ TX/RX pins swapped or not connected
    - ESP32 TX (GPIO 32) must go to servo RX
    - ESP32 RX (GPIO 25) must go to servo TX
    
  ✗ No common ground (GND)
    - ESP32 GND and servo GND MUST be connected
    - Signals float without common reference
    
  ✗ Servo not powered
    - Check servo power LED
    - Verify voltage at servo power pins
    
  ✗ Wrong servo ID
    - Servo ID configured differently than code expects
    - Default servo ID = 1, code uses ID = 2
    
  ✗ Servo in wrong protocol mode
    - Some servos have TTL half-duplex mode vs Modbus mode
    - Check servo configuration software/manual
    
  ✗ Wrong UART pins in code
    - Code defines RX=25, TX=32
    - Hardware may be wired to different pins
    
  ✗ Servo in alarm/fault state and not responding
    - Overload, overheat, voltage fault
    - Need to read error register or power cycle

Diagnostic Steps:
  1. Measure voltage at servo power pins (should be 6-12V depending on model)
  2. Swap TX/RX and test (if still fails, swap back)
  3. Use multimeter continuity test on GND connection
  4. Connect servo to manufacturer's software to verify ID and mode
  5. Try broadcast ID (0) in code as test
  6. Monitor TX pin with logic analyzer/oscilloscope - verify bits going out

Similar CAN Equivalent:
  • CAN: No ACK from any node → bus-off or no devices
  • Serial: Complete silence → wiring or power issue


2.2 INCOMPLETE READ (0 < bytesRead < expectedLen)
───────────────────────────────────────────────────────────────────────────────
Error Pattern:
  • readResponse() returns -1
  • bytesRead > 0 but < expectedLen
  • Partial frame received
  • Console: "TIMEOUT/INCOMPLETE READ: X/Y bytes"

Root Causes:
  ✗ Baud rate mismatch
    - ESP32 at 115200, servo at different rate (57600, 1000000, etc.)
    - Bits garbled, sync lost mid-frame
    
  ✗ Timeout too short
    - Servo processing takes longer than 50-100ms
    - Slow servos or busy servos may need 200ms+
    
  ✗ RTOS task preemption
    - Another high-priority task interrupted readResponse()
    - millis() advanced but bytes stopped arriving
    
  ✗ UART RX buffer overflow
    - ESP32 default RX buffer = 256 bytes
    - If not read fast enough, hardware drops bytes
    
  ✗ Intermittent connection
    - Loose wire, bad solder joint
    - Works sometimes, fails when cable moves
    
  ✗ Long cable + high baud rate
    - Signal degradation over distance
    - 115200 baud works up to ~3m typically
    - Longer cables → reduce baud rate

Diagnostic Steps:
  1. Try different baud rates (57600, 115200, 1000000)
  2. Increase timeout in readResponse(rxBuf, expectedLen, 200)
  3. Measure actual baud rate with oscilloscope (bit duration = 1/baudrate)
  4. Shorten cable to <1m as test
  5. Add delay(1) in tight loops to allow RTOS scheduling
  6. Check Serial2 buffer size in Arduino core (may need to increase)
  7. Wiggle cables while running - if errors appear, it's mechanical

Similar CAN Equivalent:
  • CAN: TWAI_ALERT_RX_QUEUE_FULL (not reading fast enough)
  • Serial: Partial frame = timeout or buffer overflow


2.3 CRC MISMATCH (bytesRead = expectedLen, but CRC wrong)
───────────────────────────────────────────────────────────────────────────────
Error Pattern:
  • readResponse() returns -2
  • All expected bytes received
  • Calculated CRC ≠ Received CRC
  • Console: "CRC MISMATCH: Recv=0xXXXX Expected=0xYYYY"

Root Causes:
  ✗ Electrical noise / EMI
    - Motor PWM cables near UART cable
    - Inductive spikes from relay/solenoid switching
    - Corrupts bits during transmission
    
  ✗ Poor cable quality
    - Unshielded cable in noisy environment
    - Cheap ribbon cables susceptible to crosstalk
    
  ✗ Ground loops
    - Multiple ground paths with different potentials
    - Current flows through signal lines
    
  ✗ Power supply ripple/noise
    - Switching regulator noise couples into signals
    - Especially if servo and ESP32 share noisy supply
    
  ✗ Cable too long
    - >3m at 115200 baud degrades signal
    - Reflections, ringing, attenuation
    
  ✗ Baud rate too high for cable
    - 1Mbps+ requires very short, high-quality cables
    - Rise/fall time violations
    
  ✗ Loose connection / oxidation
    - Intermittent contact resistance
    - Especially in connectors exposed to humidity
    
  ✗ ESP32 or servo UART peripheral malfunction
    - Rare, but hardware fault possible
    - Can be tested by swapping devices

Diagnostic Steps:
  1. Reduce baud rate to 57600 or 38400 as test
  2. Shorten cable to <0.5m as test
  3. Route UART cable away from motor/power cables
  4. Add ferrite bead on UART cable
  5. Use twisted pair or shielded cable
  6. Check power supply with oscilloscope (should be <100mV ripple)
  7. Add 0.1µF + 10µF ceramic caps close to ESP32 and servo power pins
  8. Separate power supplies for servo and ESP32 (still common GND)
  9. Count frequency of CRC errors (rare = noise, frequent = systematic)

Similar CAN Equivalent:
  • CAN: TWAI_ALERT_BUS_ERROR (bit/stuff/CRC error)
  • CAN: Frequent CRC errors → check termination, cable quality
  • Serial: Same concepts apply, but no termination resistors needed


2.4 SERVO RESPONDS BUT REJECTS COMMAND
───────────────────────────────────────────────────────────────────────────────
Error Pattern:
  • Command sends successfully (TX shown in debug)
  • Servo responds with exception frame (different length or error code)
  • Or servo echoes command but doesn't execute it

Root Causes:
  ✗ Register address not supported
    - Trying to write to read-only register
    - Trying to write to non-existent register
    - Servo model has different memory map
    
  ✗ Data out of range
    - Position exceeds configured min/max limits
    - Speed exceeds maximum rated speed
    - Acceleration value invalid
    
  ✗ Torque not enabled
    - setPosition() called but torque still disabled
    - Servo won't move until torque enabled
    
  ✗ Servo in fault/alarm mode
    - Overload, overheat, overvoltage, undervoltage
    - Must clear alarm first (write to fault reset register)
    
  ✗ Wrong function code
    - Using FC 16 (write multiple) when servo only supports FC 6 (write single)
    - Rare with SMS/Feetech, but possible
    
  ✗ Byte order error
    - Sending little-endian when servo expects big-endian
    - Results in garbage values (e.g., position 0x0180 vs 0x8001)

Diagnostic Steps:
  1. Check servo manual for exact register addresses
  2. Read servo status register to check for alarms
  3. Try writing to known-good register (e.g., LED on/off if supported)
  4. Verify position is within servo's physical range
  5. Call enableTorque(ID, true) before setPosition()
  6. Power cycle servo to clear any fault states
  7. Use manufacturer's software to verify servo is responsive

Similar CAN Equivalent:
  • CAN: SDO_ABORT 0x06020000 (object doesn't exist)
  • CAN: SDO_ABORT 0x06090030 (value out of range)
  • CAN: SDO_ABORT 0x08000022 (device state prevents operation)

================================================================================
3. TIMING / RTOS / CONCURRENCY FAILURES
================================================================================

3.1 WATCHDOG TIMER (WDT) RESET
───────────────────────────────────────────────────────────────────────────────
Error Pattern:
  • ESP32 suddenly resets mid-operation
  • Serial output: "rst:0x8 (TG1WDT_SYS_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)"
  • Or: "Task watchdog got triggered"

Root Causes:
  ✗ Blocking too long in readResponse()
    - while() loop without yield()
    - If timeout is large (e.g., 1000ms) and servo doesn't respond
    - IDLE task can't run → WDT fires
    
  ✗ Tight loop in main loop()
    - Repeatedly calling readPosition() with no delay()
    - No time for WiFi/BT/housekeeping tasks
    
  ✗ Interrupt disabled too long
    - Critical section holding off interrupts
    - UART ISR can't service RX → buffer overflow

Diagnostic Steps:
  1. Add delay(1) inside readResponse() while loop (already done in code)
  2. Add delay(10) or more in main loop()
  3. Use vTaskDelay() if using FreeRTOS tasks explicitly
  4. Monitor with: esp_task_wdt_add() / esp_task_wdt_reset()
  5. Reduce timeout values if excessively long

Prevention:
  • Always add yield()/delay(1) in blocking loops
  • Use non-blocking state machines for production code
  • Increase WDT timeout if legitimate long operations needed


3.2 TASK PREEMPTION / RACE CONDITIONS
───────────────────────────────────────────────────────────────────────────────
Error Pattern:
  • Intermittent failures (works 90% of time, fails randomly)
  • Frame appears corrupted or truncated
  • Hard to reproduce consistently

Root Causes:
  ✗ Multiple tasks using same Serial2
    - Task A sends command, Task B also writes → garbled output
    - Two tasks reading at same time → both get partial data
    
  ✗ High-priority task starves serial task
    - Your code running on Core 1, high-priority task on Core 0
    - Your task can't run → millis() timeout expires
    
  ✗ WiFi/BT stack using same UART hardware
    - Rare, but possible if UART peripherals misconfigured
    
  ✗ ISR modifying shared variables
    - If using custom ISRs, may corrupt state

Diagnostic Steps:
  1. Add mutex around all Serial2 operations if using multiple tasks
  2. Use taskENTER_CRITICAL() / taskEXIT_CRITICAL() for critical sections
  3. Reduce WiFi activity during servo commands (disable WiFi as test)
  4. Pin all servo code to same core (Core 1)
  5. Add atomic flags for state tracking

Prevention:
  • Use semaphores/mutexes for shared resources
  • Design state machines instead of blocking calls
  • Minimize ISR complexity
  • Use queue for inter-task communication


3.3 MEMORY CORRUPTION / STACK OVERFLOW
───────────────────────────────────────────────────────────────────────────────
Error Pattern:
  • Random crashes, resets, or garbled data
  • LoadProhibited or StoreProhibited exceptions
  • Buffer contents change unexpectedly

Root Causes:
  ✗ Buffer overflow in sendPacket() or readResponse()
    - Writing beyond array bounds
    - txBuf[8] but writing to index 10
    
  ✗ Stack too small for task
    - Deep function calls or large local variables
    - FreeRTOS task stack size too small
    
  ✗ Pointer to stack variable returned
    - Function returns pointer to local array
    - Array deallocated when function exits

Diagnostic Steps:
  1. Enable stack overflow checking in menuconfig
  2. Use AddressSanitizer if available
  3. Review all array accesses for bounds
  4. Check that buffer sizes match actual usage
  5. Use static analysis tools (Clang Static Analyzer, cppcheck)

Prevention:
  • Always validate buffer sizes before writes
  • Use const for read-only pointers
  • Increase task stack size if deep recursion
  • Use heap (malloc) for large buffers instead of stack

================================================================================
4. POWER SUPPLY RELATED FAILURES
================================================================================

4.1 BROWNOUT DETECTION (BOD) RESET
───────────────────────────────────────────────────────────────────────────────
Error Pattern:
  • ESP32 resets when servo moves
  • Serial output: "Brownout detector was triggered"
  • Resets seem correlated with physical motion

Root Causes:
  ✗ Shared power supply between ESP32 and servo
    - Servo draws high current during acceleration
    - Supply voltage droops → ESP32 resets at ~2.7V threshold
    
  ✗ Insufficient supply current capacity
    - PSU rated 1A, servo draws 2A peak
    
  ✗ Long/thin power wires
    - High resistance → voltage drop under load
    
  ✗ Loose power connector
    - Intermittent contact → voltage spikes/dips

Diagnostic Steps:
  1. Measure 3.3V rail with oscilloscope during servo motion
  2. Check for voltage dips below 3.0V
  3. Measure servo supply voltage under load
  4. Calculate wire gauge for current requirements
  5. Add large capacitor (1000µF+) near ESP32 power input

Prevention:
  • Separate regulators for ESP32 and servo
  • Use thick power wires (18-22 AWG for high current)
  • Add bulk capacitance (1000-4700µF) near loads
  • Ensure PSU can handle 2-3x average servo current


4.2 SUPPLY NOISE COUPLING INTO SIGNALS
───────────────────────────────────────────────────────────────────────────────
Error Pattern:
  • CRC errors during servo motion
  • No errors when servo stationary
  • Errors correlated with motor PWM frequency

Root Causes:
  ✗ Switching regulator noise on power rails
    - High-frequency ripple (100kHz - 1MHz)
    - Couples capacitively into UART lines
    
  ✗ Motor PWM interference
    - PWM edges create sharp dI/dt
    - Radiates EMI across cables
    
  ✗ Poor PCB layout / breadboard
    - Long ground return paths
    - Ground loops between sections

Diagnostic Steps:
  1. Add 0.1µF ceramic caps close to ESP32 and servo
  2. Use twisted pair or shielded cable for UART
  3. Separate motor power and signal cables
  4. Use linear regulator for ESP32 (test only)
  5. Add ferrite beads on power and signal lines

Prevention:
  • Filter power rails aggressively
  • Use star grounding topology
  • Keep signal and power cables separated
  • Use differential signaling (RS-485) if available

================================================================================
5. ESP32 UART HARDWARE LIMITATIONS
================================================================================

5.1 UART FIFO BUFFER OVERFLOW
───────────────────────────────────────────────────────────────────────────────
Symptoms:
  • Missing bytes in middle of frame
  • No timeout, but bytesRead < expectedLen

Root Causes:
  • ESP32 UART RX FIFO = 128 bytes
  • If not read quickly enough, hardware drops bytes
  • High baud rates + slow processing = overflow

Prevention:
  • Read from Serial2 frequently
  • Increase software buffer size in Arduino core
  • Use UART ISR / DMA for high-speed apps


5.2 UART FRAMING ERRORS
───────────────────────────────────────────────────────────────────────────────
Symptoms:
  • Bytes received, but values don't make sense
  • CRC errors very frequent

Root Causes:
  • Baud rate clock mismatch (e.g., 115200 vs 115385)
  • Wrong data format (8N1 vs 8E1, 8O1, etc.)
  • Sampling point misalignment

Diagnostic:
  • Check error flags in UART status register
  • Arduino Serial doesn't expose this directly
  • Use ESP-IDF uart_get_error() for detailed info


5.3 TX BUFFER FULL / UART BUSY
───────────────────────────────────────────────────────────────────────────────
Symptoms:
  • Serial2.write() blocks unexpectedly
  • Seems "frozen" during sendPacket()

Root Causes:
  • TX FIFO full (another task filling it)
  • Servo not pulling data (RX disconnected at servo end)

Prevention:
  • Check Serial2.availableForWrite() before large writes
  • Add timeout on Serial2.write() (not standard Arduino)

================================================================================
6. DIAGNOSTIC BEST PRACTICES
================================================================================

6.1 INSTRUMENTATION CHECKLIST
───────────────────────────────────────────────────────────────────────────────
✓ Enable TX/RX hex dumps (already in code)
✓ Log timestamps for timeout analysis
✓ Count errors by type (timeout vs CRC vs reject)
✓ Add performance counters:
    - Total commands sent
    - Success rate percentage
    - Average response time
✓ Use logic analyzer on TX/RX lines
✓ Use oscilloscope to check signal quality
    - Rise/fall times
    - Voltage levels (0V → 3.3V)
    - Ground stability


6.2 LAYERED DEBUGGING APPROACH
───────────────────────────────────────────────────────────────────────────────
1. Physical Layer First
   → Verify power, GND, wiring continuity
   → Use multimeter, check voltages
   
2. Electrical Layer
   → Check signal quality with scope
   → Verify baud rate timing
   
3. Protocol Layer
   → Verify frame structure (ID, FC, data, CRC)
   → Compare TX vs manufacturer's documentation
   
4. Application Layer
   → Verify register addresses, data ranges
   → Check servo configuration/mode


6.3 COMPARATIVE ANALYSIS: CAN vs UART/Serial
───────────────────────────────────────────────────────────────────────────────
CAN Advantage:
  • Built-in error detection (stuff bits, CRC, ACK)
  • Hardware alerts (TWAI_ALERT_*)
  • Bus arbitration prevents collisions
  • Multi-master capable
  • SDO abort codes provide detailed error info

Serial Advantage:
  • Simpler hardware (no transceivers needed for TTL)
  • Lower latency (no arbitration)
  • Point-to-point = no bus contention
  • Higher baud rates possible (1Mbps+)

Serial Disadvantages:
  • No hardware error reporting (must rely on CRC)
  • No standard diagnostics (unlike CAN's DTC codes)
  • Timing-critical (exact baud rate match needed)
  • More susceptible to EMI (single-ended vs differential)

================================================================================
7. TROUBLESHOOTING FLOWCHART
================================================================================

START: Command fails (timeout, CRC, or rejection)
  │
  ├─→ No response at all (bytesRead = 0)?
  │    YES → Check power, GND, TX/RX wiring, servo ID
  │    NO  → Continue
  │
  ├─→ Partial response (0 < bytesRead < expected)?
  │    YES → Check baud rate, timeout, cable length
  │    NO  → Continue
  │
  ├─→ CRC error (full frame but wrong checksum)?
  │    YES → Check cable quality, EMI, ground loops, power noise
  │    NO  → Continue
  │
  ├─→ Servo responds but doesn't move?
  │    YES → Check torque enabled, position in range, alarm state
  │    NO  → Continue
  │
  └─→ Intermittent failures (works sometimes)?
       → Check loose connections, RTOS preemption, power supply stability

================================================================================
8. EMERGENCY RECOVERY PROCEDURES
================================================================================

8.1 SERVO NOT RESPONDING AT ALL
───────────────────────────────────────────────────────────────────────────────
1. Power cycle servo (hard power off/on)
2. Try manufacturer's configuration software
3. Try broadcast ID (0) to find servo
4. Reset servo to factory defaults (consult manual)
5. Check servo LED status (decode via manual)


8.2 ESP32 KEEPS RESETTING
───────────────────────────────────────────────────────────────────────────────
1. Disable servo power, run code → if stable, it's power issue
2. Add large capacitor (1000µF) to ESP32 power
3. Use separate regulator for ESP32
4. Increase WDT timeout or disable for debug
5. Comment out servo commands, test basic Serial2 echo


8.3 WORKS ON BENCH, FAILS IN DEPLOYMENT
───────────────────────────────────────────────────────────────────────────────
1. Likely: cable length, EMI, power supply load
2. Use shielded cable
3. Reduce baud rate (115200 → 57600)
4. Add ferrite beads
5. Route cables away from motors/relays

================================================================================
9. ADVANCED: ERROR STATISTICS & LOGGING
================================================================================

Implement counters for production diagnostics:

```cpp
struct ServoErrorStats {
  uint32_t total_commands;
  uint32_t timeout_errors;
  uint32_t crc_errors;
  uint32_t reject_errors;
  uint32_t success_count;
  
  float success_rate() {
    return (float)success_count / total_commands * 100.0;
  }
};
```

Log to EEPROM or SD card for long-term analysis.

Monitor trends:
  • Success rate dropping over time → cable degradation, connector wear
  • CRC errors increasing → EMI worsening, cable damage
  • Timeouts after power-on → servo boot time insufficient

================================================================================
10. COMPARISON TABLE: ERROR CODES
================================================================================

| Error Type          | Serial Code | CAN Equivalent           | Action         |
|---------------------|-------------|--------------------------|----------------|
| No response         | -1 (0 bytes)| CAN_RX_TIMEOUT           | Check wiring   |
| Partial response    | -1 (partial)| TWAI_ALERT_RX_QUEUE_FULL | Check baud     |
| CRC mismatch        | -2          | TWAI_ALERT_BUS_ERROR     | Check EMI      |
| Command rejected    | 0 (false)   | SDO_ABORT 0x06090030     | Check data     |
| Device not ready    | 0 (false)   | SDO_ABORT 0x08000022     | Enable torque  |
| WDT reset           | (reset)     | (none)                   | Add delays     |
| Brownout reset      | (reset)     | (none)                   | Fix power      |

================================================================================
END OF DOCUMENT
================================================================================

For questions or to report issues:
- Check servo manual for model-specific behaviors
- Consult ESP32 technical reference for UART peripheral details
- Use logic analyzer (Saleae, PulseView) for definitive protocol analysis

Remember: UART is simple but timing-sensitive. CAN is complex but self-healing.
Choose based on your system requirements and noise environment.
